#pragma once
/*!
\file
\brief Заголовочный файл с описанием класса и  функций.

Данный файл содержит в себе определения основных
классов, используемых в демонстрационной программе.
*/
#include<ctime>
#include<iostream>
/*!
\brief Описывает игру Крестики-Нолики.

 В данном классе хранятся методы и данные , которые позволяют описать игру и ее логику.
     В нем хранятся:
     \param int size размер карты(поля)
     \param  int** map  массив , в котором хранятся значение наших ячеек/состояние нашей карты.
*/
class Game {
   
    int size;
    int** map;
public:
    /// <summary>
    /// Функция , которая считает  есть ли тут ноль или же икс
    ///\details Функция считает есть ли тут ноль или же икс и если там что-то из этого есть то возвращает соответствующее значение.
    /// </summary>
    /// <param name="index_string">индекс строки нашей карты</param>
    /// <param name="index_colons">индекс столбцов нашей карты</param>
    /// <param name="for_x">счетчик для иксо</param>
    /// <param name="for_zero">счетчик для нулей</param>
    /// <returns>1--если есть Х ,0--если есть 0.</returns>
    int Counter(int index_string, int index_colons, int& for_x, int& for_zero);
    /// <summary>
    /// Конструктор,который устанавливает начальный размер карты и ее начальные условия.
    /// </summary>
    /// <returns></returns>
    Game(int size );
    /// <summary>
    /// Функция ,которая проверяет: занята ли данная ячейка Х или 0.
    /// </summary>
    /// <param name="index_strings">номер строки , в которой хранится проверяемая ячейка </param>
    /// <param name="index_colons">номер столбца , в которой хранится проверяемая ячейка</param>
    /// <returns>Возвращает true-если ячейка занята X или 0 ,и false - если ячейка пуста </returns>
    bool _Is(int index_strings, int index_colons);
    /// <summary>
    /// Перегрузка оператора индексирования
    /// \details Суть перезагрузки оператора заключается в том , что мы обращаемся к массиву map и берем оттуда указатель с заданным индексом.\warning Так как мы забираем указатель оттуда , то при таком обращении game[2]-будет возвращен указатель на целый одноменрный массив
    /// </summary>
    /// <param name="index">номер индекса</param>
    /// <returns>возвращает указатель элемента с данным индексом</returns>
    int* operator [](int index);
    /// <summary>
    /// Перезагрузка  оператора присваивания.
    ///\details Обращаемся к определенной ячейке массива нашего объекта класса и заменяем ее на другую.
    /// </summary>
    /// <param name="right">значение , на котороые мы хотим изменить значение в данной ячейке</param>
    /// <returns>Возвращает функция новое значение.</returns>
    int& operator=(const int& right);
    /// <summary>
    /// Функция , которая отображет состояние нашей карты на консоль
    /// \details Функция принимает с объекта класса  двумерный массив map и в соответсвии со значениями в  этиъ ячейках они пишет в консоли соответ.символ.
    /// \details -1==данное место ничем не забито(там нету ни Х,ни 0).
    /// \details 0==ячейка забита 0.
    /// \details 1==ячейка забита Х.
    /// </summary>
    void _Create_map();
    /// <summary>
    /// Функция , собирая информацию с карты, проверяет выиграл какой-нибудь игрок или же нет.
    /// </summary>
    /// <returns>Возвращает 1-если победитель Игрок Х ,0-если победитель Игрок Y,-1-если нету победителя,size^2-если у нас ничья</returns>
    int _Win();
    /// <summary>
    /// Функция возвращает размер нашей карты.
    /// </summary>
    /// <returns>Возвращает /param size</returns>
    int _Get_size();
};
/// <summary>
/// Описывает логику(механику) игры.
/// \details В функции программа обновляет состояние карты , позволяет игрокам взаимодействовать с картой , а так же проверяет:есть ли победитель.
/// </summary>
/// <param name="game">объект нашего класса ,который представляет из себя партию</param>
void _Logic(Game& game);

